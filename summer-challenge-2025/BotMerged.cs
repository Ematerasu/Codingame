// Merged bot for Codingame – generated by merge_bot.py
// Paste into Codingame editor

using System.Buffers;
using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Numerics;
using System.Runtime.CompilerServices;
using System.Text;
using System.Threading;
using System;

// ===== BotSetup.cs =====


public static class BotSetup
{
    public const long NOGC_SIZE = 64 * 1024 * 1024; // 64 MB

    public static void Apply()
    {
        Thread.CurrentThread.CurrentCulture = CultureInfo.InvariantCulture;
        bool success = GC.TryStartNoGCRegion(NOGC_SIZE);
        if (!success)
        {
            Console.Error.WriteLine("[BotSetup] GC No-GC Region failed to start.");
        }
    }
}

// ===== Utils.cs =====


public static class Config
{
    public const bool DebugEnabled = true;
}

public enum AgentClass
{
    Gunner,
    Sniper,
    Bomber,
    Assault,
    Berserker
}

public static class AgentUtils
{
    /*──────────────────────────  dane bazowe  ──────────────────────────*/
    public static readonly IReadOnlyDictionary<AgentClass, AgentStats> Stats;
    public static readonly IReadOnlyDictionary<AgentClass, int> Balloons;
    private static readonly Dictionary<(int cd, int range, int power, int bombs), AgentClass> _reverse;

    static AgentUtils()
    {
        Stats = new Dictionary<AgentClass, AgentStats>
        {
            [AgentClass.Gunner] = new AgentStats { ShootCooldown = 1, OptimalRange = 4, SoakingPower = 16 },
            [AgentClass.Sniper] = new AgentStats { ShootCooldown = 5, OptimalRange = 6, SoakingPower = 24 },
            [AgentClass.Bomber] = new AgentStats { ShootCooldown = 2, OptimalRange = 2, SoakingPower = 8 },
            [AgentClass.Assault] = new AgentStats { ShootCooldown = 2, OptimalRange = 4, SoakingPower = 16 },
            [AgentClass.Berserker] = new AgentStats { ShootCooldown = 5, OptimalRange = 2, SoakingPower = 32 },
        };
        Balloons = new Dictionary<AgentClass, int>
        {
            [AgentClass.Gunner] = 1,
            [AgentClass.Sniper] = 0,
            [AgentClass.Bomber] = 3,
            [AgentClass.Assault] = 2,
            [AgentClass.Berserker] = 1,
        };

        _reverse = new Dictionary<(int, int, int, int), AgentClass>();
        foreach (var kv in Stats)
        {
            var key = (kv.Value.ShootCooldown, kv.Value.OptimalRange, kv.Value.SoakingPower, Balloons[kv.Key]);
            _reverse[key] = kv.Key;
        }
    }

    public static AgentClass GuessClass(int cd, int range, int power, int bombs)
        => _reverse.TryGetValue((cd, range, power, bombs), out var cls) ? cls : AgentClass.Gunner;

}

public struct BitBoard
{
    public ulong A, B, C, D;          // 0..63 | 64..127 | 128..191 | 192..255
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Set(int idx)
        => Unsafe.Add(ref A, idx >> 6) |= 1UL << (idx & 63);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Clear(int idx)
        => Unsafe.Add(ref A, idx >> 6) &= ~(1UL << (idx & 63));

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public bool Test(int idx)
        => (Unsafe.Add(ref A, idx >> 6) & (1UL << (idx & 63))) != 0;
}

// ===== Move.cs =====


public enum MoveType : byte   { None = 0, Step }
public enum CombatType : byte { None = 0, Shoot, Throw, Hunker }

public readonly struct MoveAction
{
    public readonly MoveType Type;
    public readonly byte X;
    public readonly byte Y;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public MoveAction(MoveType type, byte x = 0, byte y = 0)
        => (Type, X, Y) = (type, x, y);
}

public readonly struct CombatAction
{
    public readonly CombatType Type;
    public readonly ushort Arg1;   // X or enemyId
    public readonly byte Arg2;   // Y (THROW)

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public CombatAction(CombatType type, ushort a1 = 0, byte a2 = 0)
        => (Type, Arg1, Arg2) = (type, a1, a2);
}

public struct AgentOrder  // 8 bytes
{
    public MoveAction Move;
    public CombatAction Combat;
}

public struct TurnCommand
{
    // (slot = agentId => O(1) lookup)
    public AgentOrder[] Orders;          // length = GameState.MaxAgents

    public ulong ActiveMask;             // bit i = agent i has command

    public TurnCommand(int maxAgents)
    {
        Orders = new AgentOrder[maxAgents]; // pre-allocation ≈ 8 × 10 = 80 B
        ActiveMask = 0UL;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public readonly AgentOrder Get(int id) => Orders[id];

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void SetMove(int id, MoveAction mv)
    {
        ref var o = ref Orders[id];
        o.Move = mv;
        ActiveMask |= 1UL << id;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void SetCombat(int id, CombatAction cb)
    {
        ref var o = ref Orders[id];
        o.Combat = cb;
        ActiveMask |= 1UL << id;
    }

    public readonly IEnumerable<int> EnumerateActive()
    {
        ulong mask = ActiveMask;
        while (mask != 0)
        {
            int id = BitOperations.TrailingZeroCount(mask);
            yield return id;
            mask &= mask - 1;
        }
    }
    
    public IEnumerable<string> ToLines(GameState st, int myId)
    {
        var sb = new StringBuilder(32);

        for (int id = 0; id < GameState.MaxAgents; ++id)
        {   
            if (!st.Agents[id].Alive) continue;
            if (st.Agents[id].playerId != myId) continue;
            var ord = Orders[id];
            sb.Clear();
            sb.Append(id + 1).Append(';');

            // MOVE
            if (ord.Move.Type == MoveType.Step)
                sb.Append("MOVE ").Append(ord.Move.X).Append(' ').Append(ord.Move.Y).Append(';');

            // COMBAT
            switch (ord.Combat.Type)
            {
                case CombatType.Shoot:
                    sb.Append("SHOOT ").Append(ord.Combat.Arg1 + 1);
                    break;
                case CombatType.Throw:
                    sb.Append("THROW ").Append(ord.Combat.Arg1).Append(' ').Append(ord.Combat.Arg2);
                    break;
                case CombatType.Hunker:
                    sb.Append("HUNKER_DOWN");
                    break;
                case CombatType.None:
                    sb.Append("HUNKER_DOWN");
                    break;
            }
            yield return sb.ToString();
        }
    }
}

// ===== GameStateBit.cs =====


public enum TileType : byte
{
    Empty = 0,
    LowCover = 1,
    HighCover = 2
}

public struct AgentStats
{
    public int ShootCooldown;
    public int OptimalRange;
    public int SoakingPower;
}

public struct AgentState
{
    public int playerId;
    public byte X, Y;
    public int Cooldown;
    public int Wetness;
    public int SplashBombs;
    public bool Hunkering;
    public bool Alive;
}


public sealed class GameState
{
    // ───────────────  Consts  ───────────────
    public const int MaxAgents = 10;
    public const int MaxW = 20, MaxH = 10, Cells = MaxW * MaxH; // 200 fields

    // ───────────────  Unchanged map data  ───────────────
    public static readonly TileType[] Tiles = new TileType[Cells];  // filed in GameSetup
    public static AgentClass[] AgentClasses { get; private set; } = new AgentClass[MaxAgents];

    public static void InitStatic(TileType[] tilesFromInput, AgentClass[] classesFromInput)
    {
        if (tilesFromInput.Length != Cells) throw new ArgumentException($"Tiles length {tilesFromInput.Length} != 200");
        Array.Copy(tilesFromInput, Tiles, Cells);
        Array.Copy(classesFromInput, AgentClasses, MaxAgents);
    }

    // ───────────────  Dynamic state  ───────────────
    public readonly AgentState[] Agents;   // 10 × 32 B = 320 B
    public BitBoard Occup;        // 32 B – occupation (‑1 => bit=0)

    public byte W { get; private set; }   // 12…20
    public byte H { get; private set; }   //  6…10

    public int Turn;
    public int Score0, Score1;
    public bool IsGameOver;
    public int Winner = -1;

    private static readonly ArrayPool<AgentState> _agentPool = ArrayPool<AgentState>.Shared;

    public GameState(byte width, byte height)
    {
        Agents = _agentPool.Rent(MaxAgents);
        ClearAgents();
        W = width;
        H = height;
    }

    private GameState(byte width, byte height, AgentState[] agents, BitBoard occ, int turn, int s0, int s1, bool over, int winner)
    {
        W = width;
        H = height;
        Agents = agents;
        Occup = occ;
        Turn = turn; Score0 = s0; Score1 = s1; IsGameOver = over; Winner = winner;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public GameState FastClone()
    {
        var buf = _agentPool.Rent(MaxAgents);
        for (int i = 0; i < MaxAgents; ++i)
            buf[i] = Agents[i];
        return new GameState(W, H, buf, Occup, Turn, Score0, Score1, IsGameOver, Winner);
    }

    public void ClearAgents()
    {
        for (int i = 0; i < MaxAgents; i++)
            Agents[i] = default;
        Occup = default;
    }

    // ───────────────  Helpers ───────────────
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static int ToIndex(int x, int y) => x + y * MaxW;   // stały stride 20

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public bool InBounds(int x, int y) => (uint)x < W && (uint)y < H;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static int Mdist(int x1, int y1, int x2, int y2)
        => Math.Abs(x1 - x2) + Math.Abs(y1 - y2);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static int Cdist(int x1, int y1, int x2, int y2)
        => Math.Max(Math.Abs(x1 - x2), Math.Abs(y1 - y2));

    public int AgentAt(byte x, byte y)
    {
        int idx = ToIndex(x, y);
        if (!Occup.Test(idx)) return -1;
        for (int id = 0; id < MaxAgents; id++)
        {
            ref readonly var ag = ref Agents[id];
            if (!ag.Alive) continue;
            if (ag.X == x && ag.Y == y)
                return id;
        }
        return -1;
    }

    public void UpdateFromInput(IEnumerable<(int id, byte x, byte y, int cooldown, int bombs, int wetness)> data)
    {
        foreach (var tup in data)
        {
            ref var ag = ref Agents[tup.id];
            ag.X = tup.x;
            ag.Y = tup.y;
            ag.Cooldown = tup.cooldown;
            ag.SplashBombs = tup.bombs;
            ag.Wetness = tup.wetness;
            ag.Hunkering = false;
            ag.Alive = true;
            Occup.Set(ToIndex(ag.X, ag.Y));
        }
    }

    private readonly Queue<int> _bfsQueue = new Queue<int>(Cells);
    private readonly bool[] _visited = new bool[Cells];
    private readonly int[] _cameFrom = new int[Cells];

    public (byte x, byte y)? PathfindStep(int sx, int sy, int tx, int ty)
    {
        if (!PathCache.Ready) return null;

        int from = ToIndex(sx, sy);
        int to = ToIndex(tx, ty);

        if (Tiles[to] != TileType.Empty) return null;
        byte nx = PathCache.FirstStep[from, to, 0];
        byte ny = PathCache.FirstStep[from, to, 1];
        if (nx == 0 && ny == 0 && (sx != 0 || sy != 0)) return null; // nieosiągalny
        return (nx, ny);
    }
    
    public void ApplyInPlace(in TurnCommand p0Cmd, in TurnCommand p1Cmd, bool updateScore = true)
    {
        if (IsGameOver) return;
        ResolveMoves(in p0Cmd, in p1Cmd);
        ResolveHunker(in p0Cmd, in p1Cmd);
        ResolveCombat(in p0Cmd, in p1Cmd);
        Cleanup();

        if (!IsGameOver && updateScore)
        {
            UpdateScores();
            CheckGameOver();
        }
    }

    private void ResolveMoves(in TurnCommand c0, in TurnCommand c1)
    {
        Span<byte> fromX = stackalloc byte[MaxAgents];
        Span<byte> fromY = stackalloc byte[MaxAgents];
        Span<byte> destX = stackalloc byte[MaxAgents];
        Span<byte> destY = stackalloc byte[MaxAgents];
        Span<bool> wants = stackalloc bool[MaxAgents];

        // Inicjalizacja pozycji
        for (int id = 0; id < MaxAgents; ++id)
        {
            fromX[id] = Agents[id].X;
            fromY[id] = Agents[id].Y;
            destX[id] = fromX[id];
            destY[id] = fromY[id];
            wants[id] = false;
        }

        ExtractMoves(c0, destX, destY, wants);
        ExtractMoves(c1, destX, destY, wants);

        // Konflikt na tym samym polu → anuluj obie próby
        Span<int> first = stackalloc int[Cells];
        for (int i = 0; i < Cells; i++) first[i] = -1;

        for (int id = 0; id < MaxAgents; ++id)
        {
            if (!wants[id]) continue;
            int idx = ToIndex(destX[id], destY[id]);
            if (first[idx] == -1) first[idx] = id;
            else
            {
                wants[id] = false;
                wants[first[idx]] = false;
            }
        }

        // Jeśli agent chce wejść na pole innego, który się nie rusza
        for (int id = 0; id < MaxAgents; ++id)
        {
            if (!wants[id]) continue;
            for (int other = 0; other < MaxAgents; ++other)
            {
                if (id == other || !Agents[other].Alive) continue;
                if (Agents[other].X == destX[id] && Agents[other].Y == destY[id] && !wants[other])
                {
                    wants[id] = false;
                    break;
                }
            }
        }

        // Swap detection (A→B, B→A)
        bool changed;
        do
        {
            changed = false;
            for (int a = 0; a < MaxAgents; ++a)
            {
                if (!wants[a]) continue;
                for (int b = a + 1; b < MaxAgents; ++b)
                {
                    if (!wants[b]) continue;
                    bool swap = destX[a] == fromX[b] && destY[a] == fromY[b] &&
                                destX[b] == fromX[a] && destY[b] == fromY[a];
                    if (swap)
                    {
                        wants[a] = false;
                        wants[b] = false;
                        changed = true;
                    }
                }
            }
        } while (changed);

        // Zatwierdzenie ruchów
        for (int id = 0; id < MaxAgents; ++id)
        {
            if (!wants[id]) continue;

            int from = ToIndex(fromX[id], fromY[id]);
            int to = ToIndex(destX[id], destY[id]);
            Occup.Clear(from);
            Occup.Set(to);
            Agents[id].X = destX[id];
            Agents[id].Y = destY[id];
        }

        // ─────────────── LOCAL FUNC ───────────────
        void ExtractMoves(in TurnCommand cmd, Span<byte> destX, Span<byte> destY, Span<bool> wants)
        {
            foreach (int id in cmd.EnumerateActive())
            {
                ref readonly var mv = ref cmd.Orders[id].Move;
                if (mv.Type != MoveType.Step) continue;
                ref var ag = ref Agents[id];
                if (!ag.Alive) continue;

                int tx = mv.X, ty = mv.Y;
                if (!InBounds(tx, ty)) continue;
                if (tx == ag.X && ty == ag.Y) continue;

                int man = Math.Abs(tx - ag.X) + Math.Abs(ty - ag.Y);
                if (man == 1)
                {
                    int idx = ToIndex(tx, ty);
                    if (Tiles[idx] == TileType.Empty && !Occup.Test(idx))
                    {
                        destX[id] = (byte)tx;
                        destY[id] = (byte)ty;
                        wants[id] = true;
                    }
                    continue;
                }

                var step = PathfindStep(ag.X, ag.Y, tx, ty);
                if (step.HasValue)
                {
                    var (bx, by) = step.Value;
                    destX[id] = bx;
                    destY[id] = by;
                    wants[id] = true;
                }
            }
        }
    }

    private void ResolveHunker(in TurnCommand c0, in TurnCommand c1)
    {
        for (int id = 0; id < MaxAgents; id++) Agents[id].Hunkering = false;
        Apply(c0); Apply(c1);
        void Apply(in TurnCommand cmd)
        {
            foreach (int id in cmd.EnumerateActive())
                if (cmd.Orders[id].Combat.Type == CombatType.Hunker && Agents[id].Alive)
                    Agents[id].Hunkering = true;
        }
    }

    private void ResolveCombat(in TurnCommand c0, in TurnCommand c1)
    {
        Span<CombatAction> acts = stackalloc CombatAction[MaxAgents];
        Span<bool> has = stackalloc bool[MaxAgents];
        Collect(c0, acts, has); Collect(c1, acts, has);

        for (int id = 0; id < MaxAgents; id++)
            if (has[id])
            {
                ref readonly var cb = ref acts[id];
                switch (cb.Type)
                {
                    case CombatType.Shoot: ApplyShoot(id, cb.Arg1); break;
                    case CombatType.Throw: ApplyThrow(id, cb.Arg1, cb.Arg2); break;
                }
            }

        void Collect(in TurnCommand cmd, in Span<CombatAction> acts, in Span<bool> has)
        {
            foreach (int id in cmd.EnumerateActive())
            {
                ref readonly var c = ref cmd.Orders[id].Combat;
                if (c.Type != CombatType.None) { acts[id] = c; has[id] = true; }
            }
        }
    }

    private void ApplyShoot(int shooter, int target)
    {
        ref var s = ref Agents[shooter];
        ref var t = ref Agents[target];

        if (!t.Alive || !s.Alive || s.playerId == t.playerId) return;

        var st = AgentUtils.Stats[AgentClasses[shooter]];
        if (s.Cooldown > 0) return;

        int dist = Math.Abs(s.X - t.X) + Math.Abs(s.Y - t.Y);
        if (dist > st.OptimalRange * 2) return;

        double rangeMod = dist <= st.OptimalRange ? 1.0 : 0.5;
        double coverMod = 1.0;
        bool sameCover = false;

        int dx = t.X - s.X;
        int dy = t.Y - s.Y;

        if (Math.Abs(dx) > 1)
        {
            int adjX = -Math.Sign(dx);
            int cx = t.X + adjX;
            int cy = t.Y;
            if (InBounds(cx, cy) && Cdist(cx, cy, s.X, s.Y) > 1)
            {
                TileType cover = Tiles[ToIndex(cx, cy)];
                coverMod = Math.Min(coverMod, CoverModifier(cover));

                int sx = s.X - adjX;
                if (InBounds(sx, s.Y))
                {
                    if (ToIndex(sx, s.Y) == ToIndex(cx, cy))
                        sameCover = true;
                }
            }
        }

        if (Math.Abs(dy) > 1)
        {
            int adjY = -Math.Sign(dy);
            int cx = t.X;
            int cy = t.Y + adjY;
            if (InBounds(cx, cy) && Cdist(cx, cy, s.X, s.Y) > 1)
            {
                TileType cover = Tiles[ToIndex(cx, cy)];
                coverMod = Math.Min(coverMod, CoverModifier(cover));

                int sy = s.Y - adjY;
                if (InBounds(s.X, sy))
                {
                    if (ToIndex(s.X, sy) == ToIndex(cx, cy))
                        sameCover = true;
                }
            }
        }

        if (sameCover)
            coverMod = 1.0;

        double hunkerBonus = t.Hunkering ? 0.25 : 0.0;
        int dmg = (int)Math.Round(st.SoakingPower * rangeMod * (coverMod - hunkerBonus));
        if (dmg <= 0) return;

        t.Wetness += dmg;
        s.Cooldown = st.ShootCooldown + 1;
    }

    private void ApplyThrow(int thrower, int cx, int cy)
    {
        ref var th = ref Agents[thrower];
        if (!th.Alive || th.SplashBombs == 0) return;
        if (Math.Abs(th.X - cx) + Math.Abs(th.Y - cy) > 4) return;
        for (int id = 0; id < MaxAgents; id++)
            if (Agents[id].Alive && Math.Abs(Agents[id].X - cx) <= 1 && Math.Abs(Agents[id].Y - cy) <= 1)
                Agents[id].Wetness += 30;
        th.SplashBombs--;
    }

    private void Cleanup()
    {
        for (int id = 0; id < MaxAgents; ++id)
        {
            ref var ag = ref Agents[id];
            if (!ag.Alive) continue;
            if (ag.Wetness >= 100)
            {
                ag.Alive = false;
                Occup.Clear(ToIndex(ag.X, ag.Y));
            }
            else if (ag.Cooldown > 0) ag.Cooldown--;
        }
        ++Turn;
    }

    private void UpdateScores()
    {
        int minX0 = MaxW, maxX0 = -1, minY0 = MaxH, maxY0 = -1;
        int minX1 = MaxW, maxX1 = -1, minY1 = MaxH, maxY1 = -1;

        for (int id = 0; id < MaxAgents; ++id)
        {
            ref readonly var ag = ref Agents[id];
            if (!ag.Alive) continue;

            if (ag.playerId == 0)
            {
                minX0 = Math.Min(minX0, ag.X);
                maxX0 = Math.Max(maxX0, ag.X);
                minY0 = Math.Min(minY0, ag.Y);
                maxY0 = Math.Max(maxY0, ag.Y);
            }
            else
            {
                minX1 = Math.Min(minX1, ag.X);
                maxX1 = Math.Max(maxX1, ag.X);
                minY1 = Math.Min(minY1, ag.Y);
                maxY1 = Math.Max(maxY1, ag.Y);
            }
        }

        int diff = 0;

        // Sprawdź tylko pola które mogły być "garantowane", ale mimo wszystko sprawdź d0 i d1
        for (int y = 0; y < H; ++y)
        for (int x = 0; x < W; ++x)
        {
            // Optional: early skip jeśli poza bboxami obu stron
            int d0 = int.MaxValue, d1 = int.MaxValue;
            for (int id = 0; id < MaxAgents; ++id)
            {
                ref readonly var ag = ref Agents[id];
                if (!ag.Alive) continue;

                int d = Math.Abs(ag.X - x) + Math.Abs(ag.Y - y);
                if (ag.Wetness >= 50) d <<= 1;

                if (ag.playerId == 0) d0 = Math.Min(d0, d);
                else d1 = Math.Min(d1, d);
            }

            if (d0 < d1) diff++;
            else if (d1 < d0) diff--;
            // w przeciwnym razie nikt nie kontroluje
        }

        if (diff > 0) Score0 += diff;
        else if (diff < 0) Score1 -= diff;
    }

    private void CheckGameOver()
    {
        int lead = Score0 - Score1;
        if (lead >= 600) { IsGameOver = true; Winner = 0; return; }
        if (-lead >= 600) { IsGameOver = true; Winner = 1; return; }

        bool any0 = false, any1 = false;
        for (int id = 0; id < MaxAgents; ++id)
            if (Agents[id].Alive)
                if (Agents[id].playerId == 0) any0 = true; else any1 = true;
        if (!any0 || !any1)
        {
            IsGameOver = true; Winner = any0 ? 0 : any1 ? 1 : -1; return;
        }

        if (Turn >= 100)
        {
            IsGameOver = true;
            Winner = Score0 == Score1 ? -1 : (Score0 > Score1 ? 0 : 1);
        }
    }

    public int GetLegalOrders(int agentId, Span<AgentOrder> dst)
    {
        ref readonly var ag = ref Agents[agentId];
        if (!ag.Alive) return 0;

        Span<MoveAction> moves = stackalloc MoveAction[5];
        int mCnt = 0;
        moves[mCnt++] = new MoveAction(MoveType.Step, ag.X, ag.Y);  // Stay
        foreach (var (dx, dy) in Helpers.Dir4)
        {
            byte nx = (byte)(ag.X + dx);
            byte ny = (byte)(ag.Y + dy);
            if (!InBounds(nx, ny)) continue;

            int idx = ToIndex(nx, ny);
            if (Tiles[idx] != TileType.Empty) continue;
            if (Occup.Test(idx)) continue;

            moves[mCnt++] = new MoveAction(MoveType.Step, nx, ny);
        }

        // ─── 2.  COMBAT kandydaci ───────────────────────────────────────────
        //  |None|Hunker|Shoot*|Throw*|
        Span<CombatAction> comb = stackalloc CombatAction[MaxAgents + 2 + 81];
        int cCnt = 0;
        comb[cCnt++] = default;                              // None
        comb[cCnt++] = new CombatAction(CombatType.Hunker);  // Hunker

        // SHOOT (jeśli CD==0)
        if (ag.Cooldown == 0)
        {
            var s = AgentUtils.Stats[AgentClasses[agentId]];
            for (int trg = 0; trg < MaxAgents; ++trg)
            {
                if (trg == agentId || !Agents[trg].Alive) continue;
                if (Agents[trg].playerId == ag.playerId) continue;
                if (Mdist(ag.X, ag.Y, Agents[trg].X, Agents[trg].Y) <= s.OptimalRange * 2)
                    comb[cCnt++] = new CombatAction(CombatType.Shoot, (ushort)trg);
            }
        }

        // THROW (jeśli są bomby)
        if (ag.SplashBombs > 0)
        {
            for (int dx = -4; dx <= 4; ++dx)
                for (int dy = -4; dy <= 4; ++dy)
                {
                    if (dx == 0 && dy == 0) continue;
                    int man = Math.Abs(dx) + Math.Abs(dy);
                    if (man > 4) continue;

                    int tx = ag.X + dx, ty = ag.Y + dy;
                    if (!InBounds(tx, ty)) continue;

                    comb[cCnt++] = new CombatAction(CombatType.Throw, (ushort)tx, (byte)ty);
                }
        }

        // ─── 3.  Iloczyn kartezjański MOVE × COMBAT ─────────────────────────
        int outCnt = 0;
        for (int mi = 0; mi < mCnt; ++mi)
        {
            for (int ci = 0; ci < cCnt; ++ci)
            {
                if (outCnt >= dst.Length) return outCnt;   // bufor pełny
                dst[outCnt++] = new AgentOrder { Move = moves[mi], Combat = comb[ci] };
            }
        }
        return outCnt;
    }

    public static double CoverModifier(TileType tt)
        => tt switch
        {
            TileType.LowCover => 0.5,
            TileType.HighCover => 0.25,
            _ => 1.0
        };

}

public static class PathCache
{
    public static readonly byte[,,] FirstStep = new byte[GameState.Cells, GameState.Cells, 2];
    public static bool Ready;

    public static void Precompute(GameState st)
    {
        for (int sy = 0; sy < st.H; sy++)
            for (int sx = 0; sx < st.W; sx++)
            {
                int from = GameState.ToIndex(sx, sy);
                if (GameState.Tiles[from] != TileType.Empty) continue;

                Span<bool> visited = stackalloc bool[GameState.Cells];
                Span<int> parent = stackalloc int[GameState.Cells];

                visited.Clear();
                for (int i = 0; i < GameState.Cells; i++) parent[i] = -1;

                Span<int> queue = stackalloc int[GameState.Cells];
                int qHead = 0, qTail = 0;

                visited[from] = true;
                queue[qTail++] = from;

                while (qHead < qTail)
                {
                    int cur = queue[qHead++];
                    int cx = cur % GameState.MaxW, cy = cur / GameState.MaxW;

                    foreach (var (dx, dy) in Helpers.Dir4)
                    {
                        int nx = cx + dx, ny = cy + dy;
                        if (!st.InBounds(nx, ny)) continue;
                        int ni = GameState.ToIndex(nx, ny);
                        if (visited[ni] || GameState.Tiles[ni] != TileType.Empty) continue;

                        visited[ni] = true;
                        parent[ni] = cur;
                        queue[qTail++] = ni;
                    }
                }

                for (int ty = 0; ty < st.H; ty++)
                    for (int tx = 0; tx < st.W; tx++)
                    {
                        int to = GameState.ToIndex(tx, ty);
                        if (!visited[to]) continue;

                        // Odtwórz pierwszy krok z parent[]
                        int step = to;
                        while (parent[step] != from && parent[step] != -1)
                            step = parent[step];

                        if (step == from) continue;

                        PathCache.FirstStep[from, to, 0] = (byte)(step % GameState.MaxW);
                        PathCache.FirstStep[from, to, 1] = (byte)(step / GameState.MaxW);
                    }
            }

        Ready = true;
    }
}



// ===== GameStateReader.cs =====


public static class GameStateReader
{
    private static bool       _initDone;
    private static GameState  _baseState = null!;
    private static int turn = -1;
    public static GameState ReadFromInput(TextReader input)
    {
        if (!_initDone)
            ReadInit(input);

        var gs = _baseState.FastClone();

        int agentCount = int.Parse(input.ReadLine()!);

        for (int i = 0; i < GameState.MaxAgents; ++i)
            gs.Agents[i].Alive = false;
        List<(int id, byte x, byte y, int cooldown, int bombs, int wetness)> agents = new();
        for (int i = 0; i < agentCount; ++i)
        {
            var tok = input.ReadLine()!.Split(' ');
            int id = int.Parse(tok[0]) - 1;
            byte x = byte.Parse(tok[1]);
            byte y = byte.Parse(tok[2]);
            int cooldown = int.Parse(tok[3]);
            int bombs = int.Parse(tok[4]);
            int wetness = int.Parse(tok[5]);
            agents.Add((id, x, y, cooldown, bombs, wetness));
        }
        gs.UpdateFromInput(agents);
        _ = input.ReadLine();
        ++turn;
        gs.Turn = turn;
        return gs;
    }

    private static void ReadInit(TextReader input)
    {
        int agentDataCount  = int.Parse(input.ReadLine()!);

        var tmpAgents = new (int id,int player,int cd,int range,int power,int bombs)[agentDataCount];
        for (int i = 0; i < agentDataCount; ++i)
        {
            var t = input.ReadLine()!.Split(' ');
            tmpAgents[i] = (
                int.Parse(t[0]) - 1,
                int.Parse(t[1]),
                int.Parse(t[2]),
                int.Parse(t[3]),
                int.Parse(t[4]),
                int.Parse(t[5]));
        }

        var dims = input.ReadLine()!.Split(' ');
        int w = int.Parse(dims[0]);
        int h = int.Parse(dims[1]);

        var gs = new GameState((byte)w, (byte)h);

        foreach (var a in tmpAgents)
        {
            GameState.AgentClasses[a.id] = AgentUtils.GuessClass(a.cd, a.range, a.power, a.bombs);
            gs.Agents[a.id] = new AgentState
            {
                playerId    = a.player,
                SplashBombs = a.bombs,
                Alive       = true
            };
        }

        for (int y = 0; y < h; ++y)
        {
            string[] row = input.ReadLine()!.Split(' ');
            for (int x = 0; x < w; ++x)
            {
                int tileType = int.Parse(row[3 * x + 2]);
                GameState.Tiles[GameState.ToIndex((byte)x,(byte)y)] = (TileType)tileType;
            }
        }
        if (!PathCache.Ready)
            PathCache.Precompute(gs);
        _baseState = gs;
        _initDone  = true;
    }
}

// ===== Bots/AI.cs =====

public abstract class AI
{
    public int PlayerId { get; protected set; }

    public virtual void Initialize(int playerId) => PlayerId = playerId;

    public abstract TurnCommand GetMove(GameState state);
}

// ===== Bots/Esdeath.cs =====


public enum Phase
{
    Opening,
    MidGame,
    EndGame,
}

public enum Orders : byte
{
    StandYourGround = 0,
    Offensive = 1,
    Defensive = 2,
    Retreat = 3,
    Flank = 4,
    Hunt = 5,
}

public static class PhaseOrders
{
    public static readonly Dictionary<Phase, Orders[]> AllowedOrders = new()
    {
        [Phase.Opening] = new[] { Orders.StandYourGround, Orders.Offensive, Orders.Defensive },
        [Phase.MidGame] = new[] { Orders.StandYourGround, Orders.Offensive, Orders.Defensive },
        [Phase.EndGame] = new[] { Orders.StandYourGround, Orders.Offensive, Orders.Defensive }
    };

    public static Phase DeterminePhase(GameState st, int myId)
    {
        int total = 0, alive = 0;
        foreach (var ag in st.Agents)
        {
            if (ag.playerId != myId) continue;
            total++;
            if (ag.Alive) alive++;
        }
        int turn = st.Turn;

        if (turn < 4)
            return Phase.Opening;

        if (alive * 2 <= total)
            return Phase.EndGame;

        return Phase.MidGame;
    }

}


public sealed class Esdeath : AI
{

    // ======= Opponent model =================================================================
    private readonly AI _opponentBot;

    // ──────────────────────────────────── Search params ─────────────────────────────────────

    // ───────────────────────────────── Cover distance cache ────────────────────────────
    private HashSet<(int x, int y)>[] _coveredTiles;
    private int[] _coverDist = Array.Empty<int>();
    private bool _first = false;
    private readonly Random _rng = new();
    private readonly Stopwatch _timer = new();
    private int _lastTurn = -1;

    private readonly struct Individual
    {
        public readonly Orders[] Sequence;
        public readonly double Score;

        public Individual(Orders[] seq, double score)
        {
            Sequence = seq;
            Score = score;
        }
    }

    public Esdeath(
        AI? opponent = null
    )
    {
        _opponentBot = opponent ?? new CoverBot();
        _coveredTiles = new HashSet<(int x, int y)>[GameState.MaxW * GameState.MaxH];
    }

    public override TurnCommand GetMove(GameState st)
    {
        if (!_first)
        {
            CalculateCoveredTiles(st);
            _first = true;
        }
        Phase phase = PhaseOrders.DeterminePhase(st, PlayerId);
        Orders[] legalOrders = PhaseOrders.AllowedOrders[phase];

        int budgetMs = st.Turn == 0 ? 950 : 47;
        _timer.Restart();
        throw new NotImplementedException("Esdeath bot is not implemented yet.");

    }

    public TurnCommand GenerateOrderCommand(GameState st, Orders order, int myId)
    {
        var cmd = new TurnCommand(GameState.MaxAgents);

        for (int id = 0; id < GameState.MaxAgents; id++)
        {
            ref readonly var ag = ref st.Agents[id];
            if (!ag.Alive || ag.playerId != myId) continue;

            AgentOrder ao = order switch
            {
                Orders.Offensive       => AggressiveOrder(st, id),
                Orders.Defensive       => DefensiveOrder(st, id),
                Orders.StandYourGround => StandYourGroundOrder(st, id),
                _                      => default
            };

            cmd.Orders[id] = ao;
            cmd.ActiveMask |= 1UL << id;
        }

        return cmd;
    }

    private AgentOrder AggressiveOrder(GameState st, int id)
    {
        ref readonly var ag = ref st.Agents[id];
        var myClass = GameState.AgentClasses[id];
        var myStats = AgentUtils.Stats[myClass];

        // Przeciwny brzeg
        int targetX = st.W - 1;
        if (ag.X > st.W / 2) targetX = 0;

        // MOVE: jeden krok w stronę targetX
        byte bestX = ag.X, bestY = ag.Y;
        int bestDist = GameState.Mdist(ag.X, ag.Y, targetX, ag.Y);
        foreach (var (dx, dy) in Helpers.Dir4)
        {
            byte nx = (byte)(ag.X + dx);
            byte ny = (byte)(ag.Y + dy);
            if (!st.InBounds(nx, ny)) continue;
            int idx = GameState.ToIndex(nx, ny);
            if (GameState.Tiles[idx] != TileType.Empty || st.Occup.Test(idx)) continue;

            int d = GameState.Mdist(nx, ny, targetX, ny);
            if (d < bestDist) { bestDist = d; bestX = nx; bestY = ny; }
        }

        if (ag.SplashBombs > 0)
        {
            for (int y = 0; y < st.H; y++)
                for (int x = 0; x < st.W; x++)
                {
                    if (Math.Abs(x - ag.X) + Math.Abs(y - ag.Y) > 4) continue;

                    int enemies = 0, allies = 0;
                    for (int dy = -1; dy <= 1; dy++)
                        for (int dx = -1; dx <= 1; dx++)
                        {
                            int tx = x + dx, ty = y + dy;
                            if (!st.InBounds(tx, ty)) continue;
                            int aid = st.AgentAt((byte)tx, (byte)ty);
                            if (aid == -1) continue;
                            if (st.Agents[aid].playerId == ag.playerId) allies++; else enemies++;
                        }

                    if (enemies >= 2 && allies == 0)
                    {
                        return new AgentOrder
                        {
                            Move = new MoveAction(MoveType.Step, bestX, bestY),
                            Combat = new CombatAction(CombatType.Throw, (ushort)x, (byte)y)
                        };
                    }
                }
        }

        // COMBAT: strzelaj jeśli w zasięgu
        for (int eid = 0; eid < GameState.MaxAgents; eid++)
        {
            ref readonly var enemy = ref st.Agents[eid];
            if (!enemy.Alive || enemy.playerId == ag.playerId) continue;
            int dist = GameState.Mdist(ag.X, ag.Y, enemy.X, enemy.Y);
            if (dist <= myStats.OptimalRange * 2 && ag.Cooldown == 0)
                return new AgentOrder
                {
                    Move = new MoveAction(MoveType.Step, bestX, bestY),
                    Combat = new CombatAction(CombatType.Shoot, (ushort)eid)
                };
        }

        // inaczej: zwykły ruch i hunker
        return new AgentOrder
        {
            Move = new MoveAction(MoveType.Step, bestX, bestY),
            Combat = new CombatAction(CombatType.Hunker)
        };
    }

    private AgentOrder DefensiveOrder(GameState st, int id)
    {
        ref readonly var ag = ref st.Agents[id];
        double bestScore = double.NegativeInfinity;
        (byte x, byte y) bestMove = (ag.X, ag.Y);

        foreach (var (dx, dy) in Helpers.Dir4)
        {
            byte nx = (byte)(ag.X + dx), ny = (byte)(ag.Y + dy);
            if (!st.InBounds(nx, ny)) continue;
            int idx = GameState.ToIndex(nx, ny);
            if (GameState.Tiles[idx] != TileType.Empty || st.Occup.Test(idx)) continue;

            int coverBonus = 0;
            foreach (var (ox, oy) in Helpers.Dir4)
            {
                int cx = nx + ox, cy = ny + oy;
                if (!st.InBounds(cx, cy)) continue;
                var tile = GameState.Tiles[GameState.ToIndex(cx, cy)];
                if (tile == TileType.LowCover) coverBonus += 2;
                if (tile == TileType.HighCover) coverBonus += 4;
            }

            int allyDist = 0;
            foreach (var other in st.Agents)
            {
                if (!other.Alive || other.playerId != ag.playerId || other.X == ag.X && other.Y == ag.Y) continue;
                allyDist += 5 - GameState.Mdist(nx, ny, other.X, other.Y);  // preferuje bliżej
            }

            double score = coverBonus + allyDist;
            if (score > bestScore)
            {
                bestScore = score;
                bestMove = (nx, ny);
            }
        }

        return new AgentOrder
        {
            Move = new MoveAction(MoveType.Step, bestMove.x, bestMove.y),
            Combat = new CombatAction(CombatType.Hunker)
        };
    }

    private AgentOrder StandYourGroundOrder(GameState st, int id)
    {
        ref readonly var ag = ref st.Agents[id];

        foreach (var (dx, dy) in Helpers.Dir4)
        {
            int nx = ag.X + dx;
            int ny = ag.Y + dy;
            if (!st.InBounds(nx, ny)) continue;
            int idx = GameState.ToIndex(nx, ny);
            if (GameState.Tiles[idx] is TileType.LowCover or TileType.HighCover)
            {
                int cx = ag.X + dx, cy = ag.Y + dy;
                int cidx = GameState.ToIndex(cx, cy);
                if (!st.Occup.Test(cidx))
                {
                    return new AgentOrder
                    {
                        Move = new MoveAction(MoveType.Step, (byte)cx, (byte)cy),
                        Combat = new CombatAction(CombatType.Hunker)
                    };
                }
            }
        }

        // W przeciwnym razie: shoot jeśli widzi
        var stats = AgentUtils.Stats[GameState.AgentClasses[id]];
        if (ag.Cooldown == 0)
        {
            for (int i = 0; i < GameState.MaxAgents; ++i)
            {
                ref readonly var trg = ref st.Agents[i];
                if (!trg.Alive || trg.playerId == ag.playerId) continue;
                if (GameState.Mdist(ag.X, ag.Y, trg.X, trg.Y) <= stats.OptimalRange * 2)
                    return new AgentOrder
                    {
                        Move = new MoveAction(MoveType.Step, ag.X, ag.Y),
                        Combat = new CombatAction(CombatType.Shoot, (ushort)i)
                    };
            }
        }

        // Albo rzuć bombę jeśli warto
        if (ag.SplashBombs > 0)
        {
            for (int y = 0; y < st.H; y++)
                for (int x = 0; x < st.W; x++)
                {
                    if (Math.Abs(x - ag.X) + Math.Abs(y - ag.Y) > 4) continue;
                    int enemies = 0, allies = 0;
                    for (int dy = -1; dy <= 1; dy++)
                        for (int dx = -1; dx <= 1; dx++)
                        {
                            int tx = x + dx, ty = y + dy;
                            if (!st.InBounds(tx, ty)) continue;
                            int aid = st.AgentAt((byte)tx, (byte)ty);
                            if (aid == -1) continue;
                            if (st.Agents[aid].playerId == ag.playerId) allies++; else enemies++;
                        }
                    if (enemies >= 2 && allies == 0)
                        return new AgentOrder
                        {
                            Move = new MoveAction(MoveType.Step, ag.X, ag.Y),
                            Combat = new CombatAction(CombatType.Throw, (ushort)x, (byte)y)
                        };
                }
        }

        return new AgentOrder
        {
            Move = new MoveAction(MoveType.Step, ag.X, ag.Y),
            Combat = new CombatAction(CombatType.Hunker)
        };
    }

    private void CalculateCoveredTiles(GameState st)
    {
        _coveredTiles = new HashSet<(int x, int y)>[GameState.MaxW * GameState.MaxH];
        for (int i = 0; i < _coveredTiles.Length; i++)
            _coveredTiles[i] = new HashSet<(int x, int y)>();

        var tiles = GameState.Tiles;
        // For each potential target tile t that is adjacent to at least one cover
        for (int ty = 0; ty < st.H; ty++)
            for (int tx = 0; tx < st.W; tx++)
            {
                int tIdx = GameState.ToIndex(tx, ty);
                if (tiles[tIdx] != TileType.Empty) continue;

                // Check if t has any orthogonal neighbor cover
                bool hasCoverNeighbor = Helpers.Dir4.Any(d =>
                {
                    int cx = tx + d.x, cy = ty + d.y;
                    return st.InBounds(cx, cy) &&
                            (tiles[GameState.ToIndex(cx, cy)] == TileType.LowCover || tiles[GameState.ToIndex(cx, cy)] == TileType.HighCover);
                });
                if (!hasCoverNeighbor) continue;

                // For each possible shooter position s
                for (int sy = 0; sy < st.H; sy++)
                    for (int sx = 0; sx < st.W; sx++)
                    {
                        int sIdx = GameState.ToIndex(sx, sy);
                        if (tiles[sIdx] != TileType.Empty) continue;
                        if (GameState.Cdist(tx, ty, sx, sy) <= 1 || GameState.Mdist(tx, ty, sx, sy) > 12) continue;

                        double coverMod = 1.0;
                        bool sameCover = false;
                        int dx = tx - sx;
                        int dy = ty - sy;

                        // check x-direction cover
                        if (Math.Abs(dx) > 1)
                        {
                            int adjX = -Math.Sign(dx);
                            int cx = tx + adjX;
                            int cy = ty;
                            int cIdx = GameState.ToIndex(cx, cy);
                            var cType = st.InBounds(cx, cy) ? tiles[cIdx] : TileType.Empty;
                            if ((cType == TileType.LowCover || cType == TileType.HighCover) &&
                                GameState.Cdist(cx, cy, sx, sy) > 1)
                            {
                                coverMod = Math.Min(coverMod, GameState.CoverModifier(cType));
                                int sxCheck = sx - adjX;
                                if (st.InBounds(sxCheck, sy) && GameState.ToIndex(sxCheck, sy) == cIdx)
                                    sameCover = true;
                            }
                        }

                        // check y-direction cover
                        if (Math.Abs(dy) > 1)
                        {
                            int adjY = -Math.Sign(dy);
                            int cx = tx;
                            int cy = ty + adjY;
                            int cIdx = GameState.ToIndex(cx, cy);
                            var cType = st.InBounds(cx, cy) ? tiles[cIdx] : TileType.Empty;
                            if ((cType == TileType.LowCover || cType == TileType.HighCover) &&
                                GameState.Cdist(cx, cy, sx, sy) > 1)
                            {
                                coverMod = Math.Min(coverMod, GameState.CoverModifier(cType));
                                int syCheck = sy - adjY;
                                if (st.InBounds(sx, syCheck) && GameState.ToIndex(sx, syCheck) == cIdx)
                                    sameCover = true;
                            }
                        }

                        if (coverMod < 1.0 && !sameCover)
                            _coveredTiles[tIdx].Add((sx, sy));
                    }
            }
    }
}


// ===== Program.cs =====
class Player
{
    static void Main(string[] args)
    {

        BotSetup.Apply();
        var bot  = new Esdeath();
        int myId = int.Parse(Console.ReadLine()!);
        bot.Initialize(myId);
        while (true)
        {   
            var state = GameStateReader.ReadFromInput(Console.In);
            //Console.Error.WriteLine(state.DebugString());
            TurnCommand cmd = bot.GetMove(state);
            foreach(var line in cmd.ToLines(state, bot.PlayerId))
            {
                Console.WriteLine(line);
            }
        }
    }
}


