// Merged bot for Codingame – generated by merge_bot.py
// Paste into Codingame editor

using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Numerics;
using System.Runtime.CompilerServices;
using System.Text;
using System.Threading;
using System;

// ===== BotSetup.cs =====


public static class BotSetup
{
    public const long NOGC_SIZE = 64 * 1024 * 1024; // 64 MB

    public static void Apply()
    {
        Thread.CurrentThread.CurrentCulture = CultureInfo.InvariantCulture;
        bool success = GC.TryStartNoGCRegion(NOGC_SIZE);
        if (!success)
        {
            Console.Error.WriteLine("[BotSetup] GC No-GC Region failed to start.");
        }
    }
}

// ===== Utils.cs =====


public enum AgentClass
{
    Gunner,
    Sniper,
    Bomber,
    Assault,
    Berserker
}

public static class AgentUtils
{
    /*──────────────────────────  dane bazowe  ──────────────────────────*/
    public static readonly IReadOnlyDictionary<AgentClass, AgentStats> Stats;
    public static readonly IReadOnlyDictionary<AgentClass, int> Balloons;
    private static readonly Dictionary<(int cd, int range, int power, int bombs), AgentClass> _reverse;

    static AgentUtils()
    {
        Stats = new Dictionary<AgentClass, AgentStats>
        {
            [AgentClass.Gunner]    = new AgentStats { ShootCooldown = 1, OptimalRange = 4, SoakingPower = 16 },
            [AgentClass.Sniper]    = new AgentStats { ShootCooldown = 5, OptimalRange = 6, SoakingPower = 24 },
            [AgentClass.Bomber]    = new AgentStats { ShootCooldown = 2, OptimalRange = 2, SoakingPower = 8  },
            [AgentClass.Assault]   = new AgentStats { ShootCooldown = 2, OptimalRange = 4, SoakingPower = 16 },
            [AgentClass.Berserker] = new AgentStats { ShootCooldown = 5, OptimalRange = 2, SoakingPower = 32 },
        };
        Balloons = new Dictionary<AgentClass, int>
        {
            [AgentClass.Gunner]    = 1,
            [AgentClass.Sniper]    = 0,
            [AgentClass.Bomber]    = 3,
            [AgentClass.Assault]   = 2,
            [AgentClass.Berserker] = 1,
        };

        _reverse = new Dictionary<(int,int,int,int), AgentClass>();
        foreach (var kv in Stats)
        {
            var key = (kv.Value.ShootCooldown, kv.Value.OptimalRange, kv.Value.SoakingPower, Balloons[kv.Key]);
            _reverse[key] = kv.Key;
        }
    }

    /*──────────────────────────  API  ──────────────────────────*/
    /// <summary>
    ///  Zamiana czterech liczb z inicjalizacji na <see cref="AgentClass"/>.
    ///  Jeśli nie pasuje – zwraca <see cref="AgentClass.Gunner"/>.
    /// </summary>
    public static AgentClass GuessClass(int cd, int range, int power, int bombs)
        => _reverse.TryGetValue((cd, range, power, bombs), out var cls) ? cls : AgentClass.Gunner;

    /// <summary>
    ///  Szybka ocena, czy <paramref name="target"/> jest „łatwym celem” w starciu z <paramref name="me"/>.
    /// </summary>
    public static bool IsSoftTarget(in AgentState target, in AgentState me, in AgentStats myStats, in AgentStats targetStats)
    {
        if (!target.Alive || target.playerId == me.playerId) return false;
        bool weakerDmg   = targetStats.SoakingPower < myStats.SoakingPower;
        bool longerCd    = targetStats.ShootCooldown > myStats.ShootCooldown;
        bool lowHP       = target.Wetness > 60;
        return weakerDmg || longerCd || lowHP;
    }

    /// <summary>
    ///  Minimalna Manhattan‑distance do dowolnego przeciwnika spełniającego <paramref name="predicate"/>.
    ///  Zwraca <c>int.MaxValue</c>, jeśli brak takiego.
    /// </summary>
    public static int DistanceToClosestEnemy(GameState gs, int myId, Func<int, bool> predicate)
    {
        ref readonly var me = ref gs.Agents[myId];
        int best = int.MaxValue;
        for (int i = 0; i < GameState.MaxAgents; ++i)
        {
            if (!predicate(i)) continue;
            int d = GameState.Mdist(me.X, me.Y, gs.Agents[i].X, gs.Agents[i].Y);
            if (d < best) best = d;
        }
        return best;
    }
}

// ===== Move.cs =====


public enum MoveType : byte   { None = 0, Step }
public enum CombatType : byte { None = 0, Shoot, Throw, Hunker }

public readonly struct MoveAction
{
    public readonly MoveType Type;
    public readonly byte X;
    public readonly byte Y;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public MoveAction(MoveType type, byte x = 0, byte y = 0)
        => (Type, X, Y) = (type, x, y);
}

public readonly struct CombatAction
{
    public readonly CombatType Type;
    public readonly ushort Arg1;   // X or enemyId
    public readonly byte Arg2;   // Y (THROW)

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public CombatAction(CombatType type, ushort a1 = 0, byte a2 = 0)
        => (Type, Arg1, Arg2) = (type, a1, a2);
}

public struct AgentOrder  // 8 bytes
{
    public MoveAction Move;
    public CombatAction Combat;
}

public struct TurnCommand
{
    // (slot = agentId => O(1) lookup)
    public AgentOrder[] Orders;          // length = GameState.MaxAgents

    public ulong ActiveMask;             // bit i = agent i has command

    public TurnCommand(int maxAgents)
    {
        Orders = new AgentOrder[maxAgents]; // pre-allocation ≈ 8 × 10 = 80 B
        ActiveMask = 0UL;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public readonly AgentOrder Get(int id) => Orders[id];

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void SetMove(int id, MoveAction mv)
    {
        ref var o = ref Orders[id];
        o.Move = mv;
        ActiveMask |= 1UL << id;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void SetCombat(int id, CombatAction cb)
    {
        ref var o = ref Orders[id];
        o.Combat = cb;
        ActiveMask |= 1UL << id;
    }

    /// <summary>Fast enumeration, only for active agents</summary>
    public readonly IEnumerable<int> EnumerateActive()
    {
        ulong mask = ActiveMask;
        while (mask != 0)
        {
            int id = BitOperations.TrailingZeroCount(mask);
            yield return id;
            mask &= mask - 1;    // clear lowest bit
        }
    }
    
    public IEnumerable<string> ToLines()
    {
        var sb = new StringBuilder(32);

        for (int id = 0; id < Orders.Length; ++id)
        {
            var ord = Orders[id];
            if (ord.Move.Type == MoveType.None &&
                ord.Combat.Type == CombatType.None) continue;

            sb.Clear();
            sb.Append(id + 1).Append(';');

            // MOVE
            if (ord.Move.Type == MoveType.Step)
                sb.Append("MOVE ").Append(ord.Move.X).Append(' ').Append(ord.Move.Y).Append(';');

            // COMBAT
            switch (ord.Combat.Type)
            {
                case CombatType.Shoot:
                    sb.Append("SHOOT ").Append(ord.Combat.Arg1 + 1);
                    break;
                case CombatType.Throw:
                    sb.Append("THROW ").Append(ord.Combat.Arg1).Append(' ').Append(ord.Combat.Arg2);
                    break;
                case CombatType.Hunker:
                    sb.Append("HUNKER_DOWN");
                    break;
            }
            yield return sb.ToString();
        }
    }
}

// ===== GameState.cs =====


public enum TileType : byte
{
    Empty = 0,
    LowCover = 1,
    HighCover = 2
}

public struct AgentStats
{
    public int ShootCooldown;
    public int OptimalRange;
    public int SoakingPower;
}

public struct AgentState
{
    public int playerId;
    public byte X, Y;
    public int Cooldown;
    public int Wetness;
    public int SplashBombs;
    public bool Hunkering;
    public bool Alive;
}

public readonly struct Position
{
    public readonly byte X;
    public readonly byte Y;
    public Position(byte x, byte y) { X = x; Y = y; }
}

public sealed class GameState
{
    // ====== Consts ======
    public const int MaxAgents = 10;
    public const int MapWidth = 20;
    public const int MapHeight = 10;

    public int Width;
    public int Height;

    public TileType[] Tiles;
    public int[] Occupancy; // -1 empty

    public AgentClass[] Classes = new AgentClass[MaxAgents];
    public AgentState[] Agents = new AgentState[MaxAgents];
    public Position[] Positions = new Position[MaxAgents];

    public int MyId;
    public int Turn;
    public int Score0, Score1;
    public bool IsGameOver;
    public int Winner;          // -1 = draw, 0 / 1 = player id

    public GameState(int w = MapWidth, int h = MapHeight)
    {
        Width = w;
        Height = h;
        Tiles = new TileType[w * h];
        Occupancy = Enumerable.Repeat(-1, w * h).ToArray();
    }

    public GameState Clone()
    {
        var copy = (GameState)MemberwiseClone();

        copy.Tiles = (TileType[])this.Tiles.Clone();
        copy.Occupancy = (int[])this.Occupancy.Clone();

        copy.Classes = (AgentClass[])this.Classes.Clone();

        copy.Agents = (AgentState[])this.Agents.Clone();

        copy.Positions = new Position[MaxAgents];
        Array.Copy(this.Positions, copy.Positions, MaxAgents);

        return copy;
    }

    public bool IsInBounds(byte x, byte y)
        => x < Width && y < Height;

    public ref AgentState GetAgent(int id) => ref Agents[id];

    public int AgentAt(byte x, byte y)
        => Occupancy[ToIndex(x, y)];

    public void ApplyInPlace(in TurnCommand p0Cmd, in TurnCommand p1Cmd)
    {
        if (IsGameOver) return;
        ResolveMoves(in p0Cmd, in p1Cmd);   // 1. MOVE
        ResolveHunker(in p0Cmd, in p1Cmd);  // 2. HUNKER
        ResolveCombat(in p0Cmd, in p1Cmd);  // 3. SHOOT / THROW
        CleanupAndCooldown();               // 4. wetness / cd / turn++

        if (!IsGameOver)
        {
            UpdateScores();
            CheckGameOver();
        }
    }

    private void ResolveMoves(in TurnCommand p0Cmd, in TurnCommand p1Cmd)
    {
        Span<byte> fromX = stackalloc byte[MaxAgents];
        Span<byte> fromY = stackalloc byte[MaxAgents];
        Span<byte> destX = stackalloc byte[MaxAgents];
        Span<byte> destY = stackalloc byte[MaxAgents];
        Span<bool> wants = stackalloc bool[MaxAgents];

        for (int id = 0; id < MaxAgents; ++id)
        {
            fromX[id] = Agents[id].X;
            fromY[id] = Agents[id].Y;
            destX[id] = fromX[id];
            destY[id] = fromY[id];
            wants[id] = false;
        }

        void Extract(in TurnCommand cmd, Span<byte> destX, Span<byte> destY, Span<bool> wants)
        {
            foreach (int id in cmd.EnumerateActive())
            {
                ref readonly var mv = ref cmd.Orders[id].Move;
                if (mv.Type != MoveType.Step) continue;

                ref var ag = ref Agents[id];
                if (!ag.Alive) continue;
                if (!IsInBounds(mv.X, mv.Y)) continue;

                if (mv.X == ag.X && mv.Y == ag.Y)
                    continue;

                int manhattan = Math.Abs(ag.X - mv.X) + Math.Abs(ag.Y - mv.Y);
                if (manhattan == 1)
                {
                    int idx = ToIndex(mv.X, mv.Y);
                    if (Tiles[idx] != TileType.Empty || Occupancy[idx] != -1) continue;
                }

                byte nx = ag.X, ny = ag.Y;

                int bestDist = int.MaxValue;
                foreach (var (dx, dy) in Dir4)
                {
                    byte cx = (byte)(ag.X + dx);
                    byte cy = (byte)(ag.Y + dy);
                    if (!IsInBounds(cx, cy)) continue;

                    int idx = ToIndex(cx, cy);
                    if (Tiles[idx] != TileType.Empty) continue;
                    if (Occupancy[idx] != -1) continue;

                    int d = Math.Abs(mv.X - cx) + Math.Abs(mv.Y - cy);    // Manhattan
                    if (d < bestDist) { bestDist = d; nx = cx; ny = cy; }
                }

                if (nx == ag.X && ny == ag.Y) continue;
                destX[id] = nx; destY[id] = ny; wants[id] = true;
            }
        }

        Extract(in p0Cmd, destX, destY, wants);
        Extract(in p1Cmd, destX, destY, wants);

        Span<int> firstOnTile = stackalloc int[Width * Height];
        for (int i = 0; i < firstOnTile.Length; ++i) firstOnTile[i] = -1;

        for (int id = 0; id < MaxAgents; ++id)
        {
            if (!wants[id]) continue;
            int idx = ToIndex(destX[id], destY[id]);

            if (firstOnTile[idx] == -1)
                firstOnTile[idx] = id;
            else
            {
                wants[id] = false;
                wants[firstOnTile[idx]] = false;
            }
        }

        for (int id = 0; id < MaxAgents; ++id)
        {
            if (!wants[id]) continue;
            int idx = ToIndex(destX[id], destY[id]);
            int occ = Occupancy[idx];

            if (occ != -1 && !wants[occ])
                wants[id] = false;
        }

        bool changed;
        do
        {
            changed = false;
            for (int a = 0; a < MaxAgents; ++a)
            {
                if (!wants[a]) continue;
                for (int b = a + 1; b < MaxAgents; ++b)
                {
                    if (!wants[b]) continue;
                    bool swap = destX[a] == fromX[b] && destY[a] == fromY[b] &&
                                destX[b] == fromX[a] && destY[b] == fromY[a];
                    if (swap)
                    {
                        wants[a] = wants[b] = false;
                        changed = true;
                    }
                }
            }
        } while (changed);

        for (int id = 0; id < MaxAgents; ++id)
        {
            if (!wants[id]) continue;

            Occupancy[ToIndex(fromX[id], fromY[id])] = -1;
            Occupancy[ToIndex(destX[id], destY[id])] = id;

            Agents[id].X = destX[id];
            Agents[id].Y = destY[id];
            Positions[id] = new Position(destX[id], destY[id]);
        }
    }
    private void ResolveHunker(in TurnCommand p0Cmd, in TurnCommand p1Cmd)
    {
        for (int id = 0; id < MaxAgents; ++id)
            Agents[id].Hunkering = false;

        void ApplyHunker(in TurnCommand cmd)
        {
            foreach (int id in cmd.EnumerateActive())
            {
                ref readonly var cb = ref cmd.Orders[id].Combat;
                if (cb.Type != CombatType.Hunker) continue;
                if (!Agents[id].Alive) continue;

                Agents[id].Hunkering = true;
            }
        }

        ApplyHunker(in p0Cmd);
        ApplyHunker(in p1Cmd);
    }
    private void ResolveCombat(in TurnCommand p0Cmd, in TurnCommand p1Cmd)
    {
        Span<CombatAction> action = stackalloc CombatAction[MaxAgents];
        Span<bool> has = stackalloc bool[MaxAgents];

        void Collect(in TurnCommand cmd, Span<CombatAction> action, Span<bool> has)
        {
            foreach (int id in cmd.EnumerateActive())
            {
                ref readonly var cb = ref cmd.Orders[id].Combat;
                if (cb.Type == CombatType.None) continue;
                action[id] = cb;
                has[id] = true;
            }
        }
        Collect(in p0Cmd, action, has);
        Collect(in p1Cmd, action, has);

        for (int id = 0; id < MaxAgents; ++id)
        {
            if (!has[id]) continue;
            ref readonly var cb = ref action[id];
            switch (cb.Type)
            {
                case CombatType.Shoot:
                    ApplyShoot(id, cb.Arg1);          // Arg1 = enemyId
                    break;

                case CombatType.Throw:
                    ApplyThrow(id, cb.Arg1, cb.Arg2); // Arg1 = X, Arg2 = Y
                    break;

            }
        }
    }

    private void CleanupAndCooldown()
    {
        for (int id = 0; id < MaxAgents; ++id)
        {
            ref var ag = ref Agents[id];
            if (!ag.Alive) continue;

            if (ag.Wetness >= 100)
                ag.Alive = false;
            else if (ag.Cooldown > 0)
                ag.Cooldown--;
        }
        ++Turn;
    }

    private bool IsInBounds(int x, int y) =>
        x >= 0 && x < Width && y >= 0 && y < Height;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static int Cdist(int x1, int y1, int x2, int y2)
        => Math.Max(Math.Abs(x1 - x2), Math.Abs(y1 - y2));

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static int Mdist(int x1, int y1, int x2, int y2)
        => Math.Abs(x1 - x2) + Math.Abs(y1 - y2);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static double CoverModifier(TileType t) => t switch
    {
        TileType.HighCover => 0.25,
        TileType.LowCover => 0.50,
        _ => 1.00
    };

    private static readonly (sbyte dx, sbyte dy)[] Dir4 = { (1, 0), (-1, 0), (0, 1), (0, -1) };

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public int ToIndex(byte x, byte y) => x + y * Width;

    private void ApplyShoot(int shooterId, int targetId)
    {
        ref var shooter = ref Agents[shooterId];
        ref var target = ref Agents[targetId];
        if (shooter.playerId == target.playerId) return;
        if (!shooter.Alive || !target.Alive || shooterId == targetId) return;

        var stats = AgentUtils.Stats[Classes[shooterId]];
        if (shooter.Cooldown > 0) return;

        int dist = Mdist(shooter.X, shooter.Y, target.X, target.Y);
        if (dist > stats.OptimalRange * 2) return;

        double rangeMod = dist <= stats.OptimalRange ? 1.0 : 0.5;

        double coverMod = 1.0;

        int dx = target.X - shooter.X;
        int dy = target.Y - shooter.Y;

        bool sameCover = false;

        if (Math.Abs(dx) > 1)
        {
            int adjX = -Math.Sign(dx);
            int cx = target.X + adjX;
            int cy = target.Y;
            int idx = ToIndex((byte)cx, (byte)cy);
            if (IsInBounds((byte)cx, (byte)cy) && Cdist(cx, cy, shooter.X, shooter.Y) > 1)
            {
                var coverTile = Tiles[idx];
                var mod = CoverModifier(coverTile);
                coverMod = Math.Min(coverMod, mod);

                int sx = shooter.X - adjX;
                if (IsInBounds((byte)sx, (byte)shooter.Y))
                {
                    int shooterIdx = ToIndex((byte)sx, (byte)shooter.Y);
                    if (shooterIdx == idx)
                        sameCover = true;
                }
            }
        }

        if (Math.Abs(dy) > 1)
        {
            int adjY = -Math.Sign(dy);
            int cx = target.X;
            int cy = target.Y + adjY;
            int idx = ToIndex((byte)cx, (byte)cy);
            if (IsInBounds((byte)cx, (byte)cy) && Cdist(cx, cy, shooter.X, shooter.Y) > 1)
            {
                var coverTile = Tiles[idx];
                var mod = CoverModifier(coverTile);
                coverMod = Math.Min(coverMod, mod);

                int sy = shooter.Y - adjY;
                if (IsInBounds((byte)shooter.X, (byte)sy))
                {
                    int shooterIdx = ToIndex((byte)shooter.X, (byte)sy);
                    if (shooterIdx == idx)
                        sameCover = true;
                }
            }
        }
        if (sameCover)
            coverMod = 1.0;
        double hunkerBonus = target.Hunkering ? 0.25 : 0.0;

        int dmg = (int)Math.Round(stats.SoakingPower * rangeMod *
                                (coverMod - hunkerBonus));
        if (dmg <= 0) return;

        target.Wetness += dmg;
        shooter.Cooldown = stats.ShootCooldown + 1;
    }

    private void ApplyThrow(int throwerId, int cx, int cy)
    {
        ref var thr = ref Agents[throwerId];
        if (!thr.Alive || thr.SplashBombs <= 0) return;

        if (Mdist(thr.X, thr.Y, cx, cy) > 4) return;

        for (int id = 0; id < MaxAgents; ++id)
        {
            ref var ag = ref Agents[id];
            if (!ag.Alive) continue;

            if (Math.Abs(ag.X - cx) <= 1 && Math.Abs(ag.Y - cy) <= 1)
            {
                ag.Wetness += 30;
            }
        }
        thr.SplashBombs--;
    }

    public int GetLegalOrders(int agentId, Span<AgentOrder> dst)
    {
        ref readonly var ag = ref Agents[agentId];
        if (!ag.Alive) return 0;

        // ─── 1.  MOVE kandydaci (Stay + 4 ortogonalne puste) ────────────────
        Span<MoveAction> moves = stackalloc MoveAction[5];
        int mCnt = 0;
        moves[mCnt++] = new MoveAction(MoveType.Step, ag.X, ag.Y);  // Stay
        foreach (var (dx, dy) in Dir4)
        {
            byte nx = (byte)(ag.X + dx);
            byte ny = (byte)(ag.Y + dy);
            if (!IsInBounds(nx, ny)) continue;

            int idx = ToIndex(nx, ny);
            if (Tiles[idx] != TileType.Empty) continue;
            if (Occupancy[idx] != -1) continue;

            moves[mCnt++] = new MoveAction(MoveType.Step, nx, ny);
        }

        // ─── 2.  COMBAT kandydaci ───────────────────────────────────────────
        //  |None|Hunker|Shoot*|Throw*|
        Span<CombatAction> comb = stackalloc CombatAction[MaxAgents + 2 + 81];
        int cCnt = 0;
        comb[cCnt++] = default;                              // None
        comb[cCnt++] = new CombatAction(CombatType.Hunker);  // Hunker

        // SHOOT (jeśli CD==0)
        if (ag.Cooldown == 0)
        {
            var s = AgentUtils.Stats[Classes[agentId]];
            for (int trg = 0; trg < MaxAgents; ++trg)
            {
                if (trg == agentId || !Agents[trg].Alive) continue;
                if (Agents[trg].playerId == ag.playerId) continue;
                if (Mdist(ag.X, ag.Y, Agents[trg].X, Agents[trg].Y) <= s.OptimalRange * 2)
                    comb[cCnt++] = new CombatAction(CombatType.Shoot, (ushort)trg);
            }
        }

        // THROW (jeśli są bomby)
        if (ag.SplashBombs > 0)
        {
            for (int dx = -4; dx <= 4; ++dx)
                for (int dy = -4; dy <= 4; ++dy)
                {
                    if (dx == 0 && dy == 0) continue;
                    int man = Math.Abs(dx) + Math.Abs(dy);
                    if (man > 4) continue;

                    int tx = ag.X + dx, ty = ag.Y + dy;
                    if (!IsInBounds((byte)tx, (byte)ty)) continue;

                    comb[cCnt++] = new CombatAction(CombatType.Throw, (ushort)tx, (byte)ty);
                }
        }

        // ─── 3.  Iloczyn kartezjański MOVE × COMBAT ─────────────────────────
        int outCnt = 0;
        for (int mi = 0; mi < mCnt; ++mi)
        {
            for (int ci = 0; ci < cCnt; ++ci)
            {
                if (outCnt >= dst.Length) return outCnt;   // bufor pełny
                dst[outCnt++] = new AgentOrder { Move = moves[mi], Combat = comb[ci] };
            }
        }
        return outCnt;
    }

    private void UpdateScores()
    {
        int diff = 0;
        for (byte y = 0; y < Height; ++y)
            for (byte x = 0; x < Width; ++x)
            {
                int best0 = int.MaxValue, best1 = int.MaxValue;

                for (int id = 0; id < MaxAgents; ++id)
                {
                    ref readonly var ag = ref Agents[id];
                    if (!ag.Alive) continue;

                    int d = Math.Abs(ag.X - x) + Math.Abs(ag.Y - y);
                    if (ag.Wetness >= 50) d <<= 1;
                    if (ag.playerId == 0)
                        best0 = Math.Min(best0, d);
                    else
                        best1 = Math.Min(best1, d);
                }

                if (best0 < best1) diff++;
                else if (best1 < best0) diff--;
            }

        if (diff > 0) Score0 += diff;
        else if (diff < 0) Score1 += -diff;
    }

    private void CheckGameOver()
    {
        int lead = Score0 - Score1;
        if (lead >= 600) { IsGameOver = true; Winner = 0; return; }
        if (-lead >= 600) { IsGameOver = true; Winner = 1; return; }

        bool any0 = false, any1 = false;
        for (int i = 0; i < MaxAgents; ++i)
            if (Agents[i].Alive)
                if (Agents[i].playerId == 0) any0 = true; else any1 = true;

        if (!any0 || !any1)
        {
            IsGameOver = true;
            Winner = any0 ? 0 : any1 ? 1 : -1;
            return;
        }

        if (Turn >= 100)
        {
            IsGameOver = true;
            Winner = Score0 == Score1 ? -1 : (Score0 > Score1 ? 0 : 1);
        }
    }
    
    public override string ToString()
    {
        var sb = new StringBuilder();

        sb.AppendLine($"Turn {Turn}   P0:{Score0}  P1:{Score1}");

        for (byte y = 0; y < Height; ++y)
        {
            for (byte x = 0; x < Width; ++x)
            {
                int idx = ToIndex(x, y);
                int occ = Occupancy[idx];

                char c = occ == -1
                    ? TileChar(Tiles[idx])
                    : AgentChar((byte)occ);

                sb.Append(c);
            }
            sb.AppendLine();
        }

        sb.AppendLine();
        for (int id = 0; id < MaxAgents; ++id)
        {
            ref readonly var ag = ref Agents[id];
            if (!ag.Alive) continue;

            string side = ag.playerId == 0 ? "P0" : "P1";
            sb.AppendLine($"{id}[{side}] ({ag.X},{ag.Y}) W:{ag.Wetness} CD:{ag.Cooldown} B:{ag.SplashBombs}{(ag.Hunkering?" HUNKER":"")}");
        }

        return sb.ToString();
    }

    private static char TileChar(TileType t) => t switch
    {
        TileType.LowCover  => 'l',
        TileType.HighCover => 'h',
        _                  => '.'
    };

    private char AgentChar(byte id)
        => Agents[id].playerId == MyId
            ? (char)('A' + (id % 26)) 
            : (char)('a' + (id % 26));
}

// ===== GameStateReader.cs =====


public static class GameStateReader
{
    private static bool       _initDone;
    private static GameState  _baseState = null!;
    private static int turn = -1;
    public static GameState ReadFromInput(TextReader input)
    {
        if (!_initDone)
            ReadInit(input);

        var gs = _baseState.Clone();

        int agentCount = int.Parse(input.ReadLine()!);

        for (int i = 0; i < GameState.MaxAgents; ++i)
            gs.Agents[i].Alive = false;

        Array.Fill(gs.Occupancy, -1);

        for (int i = 0; i < agentCount; ++i)
        {
            var tok = input.ReadLine()!.Split(' ');
            int id = int.Parse(tok[0]) - 1;
            byte x = byte.Parse(tok[1]);
            byte y = byte.Parse(tok[2]);
            int cooldown = int.Parse(tok[3]);
            int bombs = int.Parse(tok[4]);
            int wetness = int.Parse(tok[5]);

            ref var ag = ref gs.Agents[id];
            ag.Alive = true;
            ag.X = x;
            ag.Y = y;
            ag.Cooldown = cooldown;
            ag.SplashBombs = bombs;
            ag.Wetness = wetness;
            ag.Hunkering = false;         // reset co turę

            gs.Positions[id] = new Position(x, y);
            gs.Occupancy[gs.ToIndex(x, y)] = id;
        }

        _ = input.ReadLine();
        ++turn;
        gs.Turn = turn;
        return gs;
    }

    //──────────────────────── init helpers ──────────────────────────────
    private static void ReadInit(TextReader input)
    {
        int myId            = int.Parse(input.ReadLine()!);
        int agentDataCount  = int.Parse(input.ReadLine()!);

        var tmpAgents = new (int id,int player,int cd,int range,int power,int bombs)[agentDataCount];
        for (int i = 0; i < agentDataCount; ++i)
        {
            var t = input.ReadLine()!.Split(' ');
            tmpAgents[i] = (
                int.Parse(t[0]) - 1,          // 1-based → 0-based
                int.Parse(t[1]),
                int.Parse(t[2]),
                int.Parse(t[3]),
                int.Parse(t[4]),
                int.Parse(t[5]));
        }

        var dims = input.ReadLine()!.Split(' ');
        int w = int.Parse(dims[0]);
        int h = int.Parse(dims[1]);

        var gs = new GameState(w, h) { MyId = myId };

        foreach (var a in tmpAgents)
        {
            gs.Classes[a.id] = AgentUtils.GuessClass(a.cd, a.range, a.power, a.bombs);
            gs.Agents[a.id] = new AgentState
            {
                playerId    = a.player,
                SplashBombs = a.bombs,
                Alive       = true
            };
        }

        for (int y = 0; y < h; ++y)
        {
            string[] row = input.ReadLine()!.Split(' ');
            for (int x = 0; x < w; ++x)
            {
                int tileType = int.Parse(row[3 * x + 2]);
                gs.Tiles[gs.ToIndex((byte)x,(byte)y)] = (TileType)tileType;
            }
        }

        _baseState = gs;
        _initDone  = true;
    }
}

// ===== Bots/AI.cs =====

public abstract class AI
{
    protected int PlayerId { get; private set; }

    public virtual void Initialize(int playerId) => PlayerId = playerId;

    public abstract TurnCommand GetMove(GameState state);
}

// ===== Bots/Esdeath.cs =====



public sealed class Esdeath : AI
{
    // ──────────────────────────────────── Tunable weights ────────────────────────────────────
    private readonly double _wTerritory;
    private readonly double _wMyWet;
    private readonly double _wOppWet;
    private readonly double _wKills;
    private readonly double _wDeaths;
    private readonly double _wCover;
    private readonly double _wDistFront;

    // ======= Opponent model =================================================================
    private readonly AI _opponentBot;

    // ──────────────────────────────────── Search params ─────────────────────────────────────
    private readonly int _depth;
    private readonly int _beamWidth;
    private readonly int _kPerAgent;

    // Re‑usable buffer to avoid allocations inside GetLegalOrders
    private readonly AgentOrder[] _ordersBuf = new AgentOrder[256];
    private readonly Node[] _beamBuf;

    private static readonly (sbyte dx, sbyte dy)[] _dirs = { (1, 0), (-1, 0), (0, 1), (0, -1) };

    public Esdeath(
        // evaluation weights (defaults are the hand‑picked values from the write‑up)
        double wTerritory = 10,
        double wMyWet = 2,
        double wOppWet = -3,
        double wKills = 5,
        double wDeaths = -4,
        double wCover = 1.5,
        double wDistFront = -0.5,
        // search hyper‑parameters
        int depth = 3,
        int beamWidth = 32,
        int kPerAgent = 6,
        AI? opponent = null
    )
    {
        _wTerritory = wTerritory;
        _wMyWet = wMyWet;
        _wOppWet = wOppWet;
        _wKills = wKills;
        _wDeaths = wDeaths;
        _wCover = wCover;
        _wDistFront = wDistFront;
        _depth = depth;
        _beamWidth = beamWidth;
        _kPerAgent = kPerAgent;
        _opponentBot = opponent ?? new GreedyBot();
        _beamBuf = new Node[_beamWidth * 4];
    }

    public override TurnCommand GetMove(GameState st)
    {
        int budgetMs = st.Turn == 0 ? 995 : 45;
        var stopwatch = Stopwatch.StartNew();
        return BeamSearch(st, _depth, _beamWidth, stopwatch, budgetMs);
    }

    // ──────────────────────────────────── Beam Search core ──────────────────────────────────
    private TurnCommand BeamSearch(GameState root, int depth, int beamW, Stopwatch sw, int budgetMs)
    {
        int curCnt = 1;
        _beamBuf[0] = new Node(root, new TurnCommand(GameState.MaxAgents), 0);
        Node best = _beamBuf[0];
        int myId = root.MyId;

        for (int d = 0; d < depth; ++d)
        {
            int nextCnt = 0;

            for (int bi = 0; bi < curCnt; ++bi)
            {
                ref Node node = ref _beamBuf[bi];
                if (sw.ElapsedMilliseconds >= budgetMs) return best.First;
                foreach (var myCmd in GenerateJointOrders(node.State, myId))
                {
                    var clone = node.State.Clone();
                    clone.ApplyInPlace(myCmd, _opponentBot.GetMove(node.State));

                    double sc = Evaluate(clone, myId);
                    var child = new Node(clone, d == 0 ? myCmd : node.First, sc);

                    if (nextCnt < _beamBuf.Length)
                        _beamBuf[nextCnt++] = child;
                    else if (sc > best.Score) // rare overflow, replace worst later
                        best = child;

                    if (sc > best.Score) best = child;
                }

                if (sw.ElapsedMilliseconds >= budgetMs) return best.First;
            }

            if (nextCnt == 0) break;
            Array.Sort(_beamBuf, 0, nextCnt, NodeComparer.Desc);
            curCnt = nextCnt < _beamWidth ? nextCnt : _beamWidth;
        }

        return best.First;
    }

    // ────────────────────────────── Joint‑order generation w/ heuristics ─────────────────────────────
    private IEnumerable<TurnCommand> GenerateJointOrders(GameState st, int kPerAgent)
    {
        // Collect my alive agents once.
        int[] ids = new int[GameState.MaxAgents];
        int n = 0;
        for (int id = 0; id < GameState.MaxAgents; ++id)
            if (st.Agents[id].Alive && st.Agents[id].playerId == PlayerId)
                ids[n++] = id;

        // 2. For each agent pick top‑k actions
        AgentOrder[][] perAgent = new AgentOrder[n][];
        int[] perCnt = new int[n];

        for (int i = 0; i < n; ++i)
        {
            int agId = ids[i];
            int cnt = CustomLegalOrders(st, agId, _ordersBuf);

            // top‑k selection (array, O(N*k))
            AgentOrder[] top = new AgentOrder[_kPerAgent];
            double[] topScore = new double[_kPerAgent];
            int tCnt = 0;

            for (int j = 0; j < cnt; ++j)
            {
                double sc = LocalHeuristic(st, agId, _ordersBuf[j]);
                if (tCnt < _kPerAgent)
                {
                    topScore[tCnt] = sc;
                    top[tCnt++] = _ordersBuf[j];
                }
                else
                {
                    // replace worst if better
                    int worstIdx = 0;
                    for (int w = 1; w < _kPerAgent; ++w)
                        if (topScore[w] < topScore[worstIdx]) worstIdx = w;
                    if (sc > topScore[worstIdx])
                    {
                        topScore[worstIdx] = sc;
                        top[worstIdx] = _ordersBuf[j];
                    }
                }
            }
            perAgent[i] = top;
            perCnt[i] = tCnt;
        }
        // Cartesian product via recursive iterator – avoids big temporary lists.
        AgentOrder[] chosen = new AgentOrder[n];
        return Enumerate(0);

        IEnumerable<TurnCommand> Enumerate(int idx)
        {
            if (idx == n)
            {
                var cmd = new TurnCommand(GameState.MaxAgents);
                for (int a = 0; a < n; ++a)
                {
                    int aid = ids[a];
                    cmd.SetMove(aid, chosen[a].Move);
                    cmd.SetCombat(aid, chosen[a].Combat);
                }
                yield return cmd;
                yield break;
            }

            for (int k = 0; k < perCnt[idx]; ++k)
            {
                chosen[idx] = perAgent[idx][k];
                foreach (var c in Enumerate(idx + 1))
                    yield return c;
            }
        }
    }
    
    private int CustomLegalOrders(GameState st, int agentId, Span<AgentOrder> dst)
    {
        int cnt = st.GetLegalOrders(agentId, dst);

        // Sniper – stay near cover (<=4 tiles Manhattan)
        if (st.Classes[agentId] == AgentClass.Sniper)
        {
            int w = 0;
            for (int i = 0; i < cnt; ++i)
            {
                ref readonly var mv = ref dst[i].Move;
                if (mv.Type != MoveType.Step) { dst[w++] = dst[i]; continue; }
                if (DistanceToNearestCover(st, mv.X, mv.Y) <= 4)
                    dst[w++] = dst[i];
            }
            cnt = w;
        }
        // TODO: add other class‑specific pruning (Bomber focus clusters etc.)
        return cnt;
    }

    private static int DistanceToNearestCover(GameState st, int x, int y)
    {
        int best = int.MaxValue;
        for (int j = 0; j < st.Height; ++j)
            for (int i = 0; i < st.Width; ++i)
            {
                TileType tt = st.Tiles[st.ToIndex((byte)i, (byte)j)];
                if (tt == TileType.Empty) continue;
                int d = Math.Abs(i - x) + Math.Abs(j - y);
                if (d < best) best = d;
            }
        return best;
    }

    // ─────────────────────────────────── Local (per‑agent) heuristic ──────────────────────────────────
    private double LocalHeuristic(GameState st, int agentId, in AgentOrder ord)
    {
        double score = 0;
        AgentClass cls = st.Classes[agentId];

        // Combat type bonus
        switch (ord.Combat.Type)
        {
            case CombatType.Shoot: score += 100; break;
            case CombatType.Throw: score += 80; break;
            case CombatType.Hunker: score += 20; break;
        }

        // Finisher incentive
        if (ord.Combat.Type == CombatType.Shoot)
        {
            int trg = ord.Combat.Arg1;
            if (trg >= 0 && trg < GameState.MaxAgents && st.Agents[trg].Alive && st.Agents[trg].Wetness >= 80)
                score += 50;
        }

        // Movement evaluation
        if (ord.Move.Type == MoveType.Step)
        {
            int nx = ord.Move.X, ny = ord.Move.Y;
            score -= Math.Abs(nx - st.Width / 2); // push forward
            if (NeighbourCover(st, nx, ny, out bool high)) score += high ? 20 : 10;
        }

        // Class‑specific tweaks
        if (cls == AgentClass.Bomber && ord.Combat.Type == CombatType.Throw) score += 25;
        return score;
    }

    private static bool NeighbourCover(GameState st, int x, int y, out bool high)
    {
        high = false;
        foreach (var (dx, dy) in _dirs)
        {
            int nx = x + dx, ny = y + dy;
            if (!st.IsInBounds((byte)nx, (byte)ny)) continue;
            TileType tt = st.Tiles[st.ToIndex((byte)nx, (byte)ny)];
            if (tt == TileType.HighCover) { high = true; return true; }
            if (tt == TileType.LowCover) return true;
        }
        return false;
    }

    // ─────────────────────────────────── State evaluation ───────────────────────────────────
    private double Evaluate(GameState gs, int myId)
    {
        int territory = myId == 0 ? gs.Score0 - gs.Score1 : gs.Score1 - gs.Score0;
        int myWet = 0, oppWet = 0, myDead = 0, oppDead = 0;
        double coverBonus = 0, distFront = 0;

        for (int id = 0; id < GameState.MaxAgents; ++id)
        {
            ref readonly var ag = ref gs.Agents[id];
            if (!ag.Alive)
            {
                if (ag.playerId == myId) myDead++; else oppDead++;
                continue;
            }

            if (ag.playerId == myId)
            {
                myWet += 100 - ag.Wetness;
                distFront += Math.Abs(ag.X - gs.Width / 2);
                coverBonus += CoverScore(gs, ag);
            }
            else
            {
                oppWet += 100 - ag.Wetness;
            }
        }

        return  _wTerritory * territory +
                _wMyWet     * myWet     +
                _wOppWet    * oppWet    +
                _wKills     * oppDead   +
                _wDeaths    * myDead    +
                _wCover     * coverBonus+
                _wDistFront * distFront;
    }

    private static double CoverScore(GameState gs, in AgentState ag)
    {
        double best = 0;
        foreach (var (dx, dy) in _dirs)
        {
            int nx = ag.X + dx;
            int ny = ag.Y + dy;
            if (nx < 0 || ny < 0 || nx >= gs.Width || ny >= gs.Height) continue;
            TileType tt = gs.Tiles[gs.ToIndex((byte)nx, (byte)ny)];
            if (tt == TileType.HighCover) best = Math.Max(best, 0.75);
            else if (tt == TileType.LowCover) best = Math.Max(best, 0.50);
        }
        return best;
    }

    // ─────────────────────────────────── Helper types ─────────────────────────────────────────
    private readonly record struct Node(GameState State, TurnCommand First, double Score);

    private sealed class NodeComparer : IComparer<Node>
    {
        public static readonly NodeComparer Desc = new();
        public int Compare(Node x, Node y) => y.Score.CompareTo(x.Score);
    }

}


// ===== Program.cs =====
class Player
{
    static void Main(string[] args)
    {

        BotSetup.Apply();
        var bot  = new Esdeath();
        bool init = false;   
        while (true)
        {
            var state = GameStateReader.ReadFromInput(Console.In);
            if (!init)
            {
                bot.Initialize(state.MyId);
                init = true;
            }
            TurnCommand cmd = bot.GetMove(state);
            foreach(var line in cmd.ToLines())
            {
                Console.WriteLine(line);
            }
        }
    }
}


